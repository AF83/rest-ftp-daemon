#!/usr/bin/env ruby

# Try to load libs
begin
  require "thin"
  require 'optparse'
  require 'socket'
  require 'timeout'
rescue LoadError
  raise "EXITING: some of basic libs were not found: thin, optparse, socket, timeout"
end
puts

# Detect environment from options
begin
  OptionParser.new do |opts|
    opts.on("-e", "--environment ENV")   { |env| APP_ENV = env }
    opts.on("-d", "--dev")               { APP_ENV = "development" }
  end.parse(ARGV)
rescue OptionParser::InvalidOption => e
end

# Load remaining libs and config subsystem
app_root = File.dirname(__FILE__) + '/../'
[:constants, :helpers, :config].each do |lib|
  require File.expand_path("#{app_root}/lib/rest-ftp-daemon/#{lib.to_s}.rb")
end

# Setup options and import current ARGV
options = {}
parser = OptionParser.new do |opts|
  opts.banner = "Usage: #{File.basename $0} [options] start|stop|restart"
  opts.on("-e", "--environment ENV", "Environment (#{APP_ENV if defined? APP_ENV})")
  opts.on("--dev", "Force development environment")
  opts.on("-p", "--port PORT", "use PORT (#{Settings.port})")          { |port| options["port"] = port.to_i }
  opts.on("-d", "--daemonize", "Run daemonized in the background")     { |bool| options["daemonize"] = bool || true }
  opts.on("-P", "--pid FILE", "File to store PID")                     { |file| options["pidfile"] = file }
  opts.on("-u", "--user NAME", "User to run daemon as (use with -g)")  { |user| options["user"] = user }
  opts.on("-g", "--group NAME", "Group to run daemon as (use with -u)")  { |group| options["group"] = group }
  opts.on_tail("-h", "--help", "Show this message")                    { puts opts; exit }
  opts.on_tail('-v', '--version', "Show version")                      { puts Settings['app_ver']; exit }
end
begin
  parser.order!(ARGV)
  command = ARGV.shift
  unless ["start", "stop", "restart"].include? command
    puts parser
    exit 1
  end
rescue OptionParser::InvalidOption => e
  puts "EXITING: option parser: #{e.message}"
  exit 1
end
Settings.merge!(options)

# Display compiled configuration
puts "--- #{APP_NAME} #{APP_VER}"
puts "Config file  \t #{APP_CONF}"
puts "PID file     \t #{Settings.pidfile}"
puts "Namespace    \t #{Settings.namespace}"
puts "Network port \t #{Settings['port']}"
puts "Daemonize    \t #{Settings['daemonize']}"
puts "User:group   \t #{Settings['user']}:#{Settings['group']}"
puts
puts Settings.to_hash.to_yaml( :Indent => 4, :UseHeader => true, :UseVersion => false )
puts

# Validate network configuration
if ["start", "restart"].include? command
  if Settings['port'].nil?
    puts "ABORTING: Network port is missing"
    exit 1
  elsif RestFtpDaemon::Helpers.local_port_used?(Settings['port'])
    puts "ABORTING: Network port is already in use" if Settings.port_used?
    exit 1
  end
end

# Build final ARGV
argv = []
argv << ["-e", Settings.namespace]
argv << ["-p", Settings["port"].to_s] unless Settings["port"].nil?
argv << ["--pid", Settings.pidfile]
argv << ["--log", Settings["logs"]["thin"].to_s] unless Settings["logs"]["thin"].nil? if Settings["logs"].is_a? Enumerable
argv << ["--daemonize"] if [1, true].include? Settings["daemonize"]
# User / group
if Settings["user"] && Settings["group"]
  argv << ["--user", Settings["user"]]
  argv << ["--group", Settings["group"]]
end
argv << command unless command.nil? rescue nil
puts "--- Thin ARGV"
puts argv.flatten.join(' ')
puts

# Start Thin with this rackup configuration
begin
  Thin::Runner.new(argv.flatten).run!
  rescue RuntimeError => e
    puts "FAILED: RuntimeError: #{e.message}"
  rescue Thin::PidFileExist
    puts "FAILED: daemon was already running (Thin::PidFileExist)"
  rescue Thin::PidFileNotFound
    puts "FAILED: daemon was not running (Thin::PidFileNotFound)"
  rescue SystemExit
    # puts "EXITING: daemon in the background (SystemExit)"
  else
    # puts "FAILED: process ending"
end
